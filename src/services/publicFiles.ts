// Service for scanning and managing public directory files

export interface PublicFile {
  name: string;
  path: string;
  relativePath: string;
  type: 'image' | 'document' | 'video' | 'other';
  size?: number;
  folder: string;
  isDirectory: boolean;
}

export interface PublicDirectory {
  name: string;
  path: string;
  files: PublicFile[];
  subdirectories: PublicDirectory[];
}

// Common image extensions
const IMAGE_EXTENSIONS = ['.jpg', '.jpeg', '.png', '.gif', '.svg', '.webp', '.bmp', '.ico'];
const VIDEO_EXTENSIONS = ['.mp4', '.webm', '.ogg', '.avi', '.mov'];
const DOCUMENT_EXTENSIONS = ['.pdf', '.doc', '.docx', '.txt', '.md'];

// Get file type based on extension
export const getFileType = (filename: string): PublicFile['type'] => {
  const ext = filename.toLowerCase().substring(filename.lastIndexOf('.'));
  
  if (IMAGE_EXTENSIONS.includes(ext)) return 'image';
  if (VIDEO_EXTENSIONS.includes(ext)) return 'video';
  if (DOCUMENT_EXTENSIONS.includes(ext)) return 'document';
  return 'other';
};

// Check if file is previewable (image or SVG)
export const isPreviewable = (filename: string): boolean => {
  const ext = filename.toLowerCase().substring(filename.lastIndexOf('.'));
  return IMAGE_EXTENSIONS.includes(ext);
};

// Get file URL for public files
export const getPublicFileUrl = (relativePath: string): string => {
  // Remove leading slash if present
  const cleanPath = relativePath.startsWith('/') ? relativePath.substring(1) : relativePath;
  return `http://movesinternational.com.bd/${cleanPath}`;
};

// Get different path formats for copying
export const getPathFormats = (relativePath: string) => {
  const webPath = getPublicFileUrl(relativePath);
  const codePath = `./public/${relativePath}`;
  
  return {
    web: webPath,
    code: codePath
  };
};

// Real implementation for scanning public directory
// Fetches the manifest file generated by the build script
export const scanPublicDirectory = async (): Promise<PublicFile[]> => {
  try {
    const response = await fetch('/public-files-manifest.json');
    
    if (!response.ok) {
      console.warn('Public files manifest not found, using fallback');
      return getFallbackFiles();
    }
    
    const files: PublicFile[] = await response.json();
    return files;
  } catch (error) {
    console.warn('Error loading public files manifest:', error);
    return getFallbackFiles();
  }
};

// Fallback files if manifest is not available
const getFallbackFiles = (): PublicFile[] => {
  return [
    {
      name: 'favicon.ico',
      path: '/favicon.ico',
      relativePath: 'favicon.ico',
      type: 'image',
      folder: 'root',
      isDirectory: false
    },
    {
      name: 'placeholder.svg',
      path: '/placeholder.svg',
      relativePath: 'placeholder.svg',
      type: 'image',
      folder: 'root',
      isDirectory: false
    }
  ];
};

// Get files by folder
export const getFilesByFolder = (files: PublicFile[], folder: string): PublicFile[] => {
  if (folder === 'all') return files;
  return files.filter(file => file.folder === folder);
};

// Get unique folders from files
export const getFolders = (files: PublicFile[]): string[] => {
  const folders = new Set(files.map(file => file.folder));
  return Array.from(folders).sort();
};

// Search files by name
export const searchFiles = (files: PublicFile[], searchTerm: string): PublicFile[] => {
  if (!searchTerm) return files;
  return files.filter(file => 
    file.name.toLowerCase().includes(searchTerm.toLowerCase())
  );
};